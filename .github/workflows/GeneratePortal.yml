name: Create and deploy portal

on:
  push:
    branches:
      - main
      - dev

jobs:
  collect_dirs:
    runs-on: ubuntu-latest
    outputs:
      dirs: ${{ steps.collect-dirs.outputs.dirs }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Collect Changed Directories
        id: collect-dirs
        run: |
          # Get the list of directories with changes
          CHANGED_DIRS=$(git diff --name-only --diff-filter=AM HEAD~1 HEAD | xargs -n1 dirname | sort -u)

          # Filter directories that contain 'BuildFiles'
          FILTERED_DIRS=$(echo "$CHANGED_DIRS" | while read -r dir; do
            if [ -d "$dir/BuildFiles" ]; then
              echo "$dir"
            fi
          done | jq -R -s -c 'split("\n") | map(select(length > 0))')

          echo "directories=$FILTERED_DIRS" >> $GITHUB_ENV
          echo "::set-output name=dirs::$FILTERED_DIRS"
   
  build_and_deploy:
    needs: collect_dirs
    runs-on: ubuntu-latest
    strategy:
      matrix:
        directory: ${{ fromJson(needs.collect_dirs.outputs.dirs) }}
    if: ${{ needs.collect_dirs.outputs.dirs != '[]' }} # Only run if directories are found

    steps:
      - name: Debug Changed Directories
        run: |
          echo "CHANGED_DIRS: ${{ needs.collect_dirs.outputs.dirs }}"

      - name: Checkout code
        uses: actions/checkout@v3

      - name: Zip BuildFiles and send to APIMatic
        run: |
          cd ${{ matrix.directory }}
          echo "Zipping BuildFiles in ${{ matrix.directory }}..."
          zip -r portal-input.zip BuildFiles/* > /dev/null
          echo "Zipped BuildFiles successfully."

          echo "Sending zip to APIMatic..."
          RESPONSE=$(curl -s --output response.zip --write-out '%{http_code}\t%{content_type}' --request POST \
                      --url 'https://api.apimatic.io/portal' \
                      -H 'Authorization: X-Auth-Key ${{ secrets.APIMATIC_API_KEY }}' \
                      -F "file=@portal-input.zip")
          
          echo "Raw curl response: $RESPONSE"
          HTTP_CODE=$(echo "$RESPONSE" | cut -f1)
          CONTENT_TYPE=$(echo "$RESPONSE" | cut -f2)

          if [ "$HTTP_CODE" -ne 200 ]; then
            echo "APIMatic transformer failed with HTTP_CODE=$HTTP_CODE. Exiting."
            exit 1
          fi

          echo "Request successful. Unzipping response..."
          mkdir -p Portal
          unzip -qq response.zip -d Portal

      - name: Check and Create Cloudflare Project if Needed
        run: |
          PROJECT_NAME=$(basename ${{ matrix.directory }})-apimatic-testrun
          echo "Checking if Cloudflare project '$PROJECT_NAME' exists..."

          # Fetch all existing Cloudflare projects
          EXISTING_PROJECTS=$(curl -s --request GET \
            --url https://api.cloudflare.com/client/v4/accounts/${{ secrets.CLOUDFLARE_ACCOUNT_ID }}/pages/projects?&per_page=500\
            --header 'Content-Type: application/json' \
            -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" | jq -r '.result[].name')

          # Check if the current project name exists in the list
          if echo "$EXISTING_PROJECTS" | grep -q "^$PROJECT_NAME$"; then
            echo "Project '$PROJECT_NAME' already exists on Cloudflare."
          else
            echo "Project '$PROJECT_NAME' not found. Creating new Cloudflare project..."

            # Create the new project
            CREATE_RESPONSE=$(curl -s --request POST \
              --url https://api.cloudflare.com/client/v4/accounts/${{ secrets.CLOUDFLARE_ACCOUNT_ID }}/pages/projects \
              --header 'Content-Type: application/json' \
              -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
              --data '{
                "name": "'"$PROJECT_NAME"'",
                "production_branch": "main"
              }')

            # Check if the project creation was successful
            if echo "$CREATE_RESPONSE" | jq -e '.success' > /dev/null; then
              echo "Successfully created Cloudflare project '$PROJECT_NAME'."
            else
              echo "Failed to create Cloudflare project '$PROJECT_NAME'. Response: $CREATE_RESPONSE"
              exit 1
            fi
          fi

      - name: Deploy to Cloudflare Pages
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          command: pages deploy ${{ matrix.directory }}/Portal --project-name=${{ matrix.directory }}-apimatic-testrun

  update_readme:
    needs: build_and_deploy
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Truncate README.md and Append Filtered Subdomains
        run: |
          # Truncate README.md after line 74
          head -n 74 README.md > temp_README.md && mv temp_README.md README.md

          echo "\\" >> README.md
      
          # Fetch the list of Cloudflare Pages projects and filter subdomains containing '-apimatic-testrun'
          curl --silent --request GET \
            --url https://api.cloudflare.com/client/v4/accounts/${{ secrets.CLOUDFLARE_ACCOUNT_ID }}/pages/projects \
            --header 'Content-Type: application/json' \
            -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" | \
            jq -r '.result[] | select(.subdomain | contains("-apimatic-testrun")) | .subdomain' | \
            sed 's/^/<http:\/\//' | sed 's/$/>/' >> README.md
      
          # Output the updated README for debugging purposes
          echo "Updated README.md content:"
          cat README.md

      - name: Commit and Push the Updated README.md
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git add README.md
          git commit -m "Update README.md with filtered Cloudflare subdomains"
          git push
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        
